# Описание JSON файла
- `sizes` - Это размеры в нашей системы. У каждого размера есть имя, и значения мерок, которые описывают данный размер. 
Кроме этого - для каждого размера существует свой аватар sizes[0]. avatar_ident, он нужен для того, что бы 
примерять одежду нужного размера на правильном аватаре. Это требуется для гостей сайта, которые не указали еще
 свой размер в системе.
- `cloth` - одежда. У одежды есть продаваемые размеры и изображения. 
- `cloth.sizes` - это размеры. тут важным параметров является ident и name. ident - это как раз идентификатор одежды, 
который вызывается через loadProduct() в плагине.
- `cloth.images` - картинки
- `user` - текущая инфомрация о пользователе
- `user.avatars` - манекены пользователя.
- `user.avatars[0].ident` - ID аватара, который используется в методе loadDummy() плагина.
- `user.default_size_id` - ID размера (sizes) по умолчанию


# Flow на текущую итерацию

В текущей итерации не используем users вообще из JSON. Оперируем только `sizes`, `cloth`, `cloth.sizes`, `cloth.images`.

Загружаем JSON сразу при инициализации плагина. Плагин СРАЗУ делаем на весь экран по ширине и высоте.

Работает с продуктивной БД. Т.е. в инициализации плагина `'host': 'http://plugin-web.globedrobe.com/api'`.

## Первая кнопка - вызов каталога

Тут все просто - берем из JSON все что есть в cloth и выводим следующие поля:

- name
- price
- images - только ту, у которой стоит `"use_as_preview": true`.

Если поле `without_discount_price` заполнено, значит выводем две цены, `cloth.without_discount_price` зачеркнутой, и
рядом красным цветом `cloth.price`.

Т.к. в данной итерации нет размеров, то берем первый размер из массива cloth.sizes[0]. Но, нам важно одежду
одного размера мерить на соответствующем аватаре. Поэтому, такой flow.

1. Берем первый размер  cloth.sizes[0] и смотрим его свойство `ident`. Это именно та вещь, которую нужно будет 
грузить методом `loadProducts()`

2. Так же из cloth.sizes[0] берем параметр `size_id`. По этому ID ищем размер в массиве  `sizes` и далее
забираем параметр `avatar_ident`. Это как раз ID аватара, который мы используем в методе loadDummy().


В модальнике с каталогом отображаются сразу все вещи, без возможности фильтрации
и скролла (постраничной навигации).


## Наведение на вещь
При наведении на товар (верх или низ отдельно) сбоку появляется бабл с названием вещи, брендом, ценой и кнопками 
подробнее и купить.


## Информация об одной вещи - кнопка подробнее

По клику на эту кнопку открывается еще одно модальное окно с подробным описание вещи.
В окне выводим:
- name
- price +  without_discount_price (така же обработка, как и в случае с кнопкой каталога)
- все катринки (с возможность пролистывания)
- кнопки Купить, Wish List.


# Кнопки купить и wish list

Функционал реализуем фейковый. Т.е. по факту ни списка желайний, ни корзины не будет. Но 
визуально мы должны отобразить обе кнопки, loader при клике на нее и реакцию после нажатия на кнопку. 
Сделать ajax, который бы обрашался к фейковому обработчику, который на выходе получает json. Можно создать 
такие файлы в папке `resources`, например `card.json` и `with-list.json`.

По кнопке купить - отображаем лоадер в процессе загрузки, и затем сообщение об успешном добавлении в корзину.

По кнопке WishList - сердечко становится красным, или наоборот - обесцвечивается. Ну т.е. сам контрол можно 
реализовать в виде сердца, или кнопки. Так же меняющей цвет и надпись по клику на нее.


# Поведение остальных контролов в VR

Любая кнопка в VR должна срабатывать не сразу, а после небольшой задержки. 
Причем прогресс этой задерки должен быть виден. Можно использовать вариант
с круговым курсором.. Который постепенно заполняется.


В данной итерации берем события:
- клик на товаре
- клик по кнопке Каталог
- клик под кнопке Примерить
- клик по кнопке Wish List
- клик по кнопке Купить
- клик по кнопке Подробнее